using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;

// Структуры Date, FullName и DataRecord остаются без изменений

public struct Date : IEquatable<Date>, IComparable<Date>
{
    public int Day { get; set; }
    public int Month { get; set; }
    public int Year { get; set; }

    public Date(int day, int month, int year)
    {
        Day = day;
        Month = month;
        Year = year;
    }

    public override string ToString() => $"{Year:D4}-{Month:D2}-{Day:D2}";

    public bool Equals(Date other) => Day == other.Day && Month == other.Month && Year == other.Year;
    public override bool Equals(object obj) => obj is Date other && Equals(other);
    public override int GetHashCode() => HashCode.Combine(Day, Month, Year);

    public int CompareTo(Date other)
    {
        if (Year != other.Year) return Year.CompareTo(other.Year);
        if (Month != other.Month) return Month.CompareTo(other.Month);
        return Day.CompareTo(other.Day);
    }
}

public struct FullName : IEquatable<FullName>, IComparable<FullName>
{
    public string LastName { get; set; }
    public string FirstName { get; set; }
    public string MiddleName { get; set; }

    public FullName(string lastName, string firstName, string middleName)
    {
        LastName = lastName;
        FirstName = firstName;
        MiddleName = middleName;
    }

    public override string ToString() => $"{LastName} {FirstName} {MiddleName}";

    public bool Equals(FullName other) => LastName == other.LastName && FirstName == other.FirstName && MiddleName == other.MiddleName;
    public override bool Equals(object obj) => obj is FullName other && Equals(other);
    public override int GetHashCode() => HashCode.Combine(LastName, FirstName, MiddleName);

    public int CompareTo(FullName other)
    {
        int lastNameComparison = string.Compare(LastName, other.LastName, StringComparison.Ordinal);
        if (lastNameComparison != 0) return -lastNameComparison;
        int firstNameComparison = string.Compare(FirstName, other.FirstName, StringComparison.Ordinal);
        if (firstNameComparison != 0) return -firstNameComparison;
        return -string.Compare(MiddleName, other.MiddleName, StringComparison.Ordinal);
    }
}

public class DataRecord : IComparable<DataRecord>
{
    public Date Date { get; set; }
    public FullName Name { get; set; }
    public int OriginalLineNumber { get; set; }

    public DataRecord(Date date, FullName name, int lineNumber)
    {
        Date = date;
        Name = name;
        OriginalLineNumber = lineNumber;
    }

    public override string ToString() => $"{Date}\t{Name}\t{OriginalLineNumber}";

    public int CompareTo(DataRecord other)
    {
        int dateComparison = Date.CompareTo(other.Date);
        return dateComparison != 0 ? dateComparison : Name.CompareTo(other.Name);
    }
}

public class Program
{
    public static void Main(string[] args)
    {
        string inputFile = @"C:\output.txt";
        int n = 1000000;

        try
        {
            Console.WriteLine($"Чтение данных из файла: {inputFile}");
            DataRecord[] data = ReadData(inputFile, n);

            if (data.Length == 0)
            {
                Console.WriteLine("Нет данных для обработки. Программа завершена.");
                return;
            }

            Console.WriteLine($"Прочитано {data.Length} записей");

            DataRecord[] dataForPyramidalSort = new DataRecord[data.Length];
            DataRecord[] dataForTwoWayInsertion = new DataRecord[data.Length];
            Array.Copy(data, dataForPyramidalSort, data.Length);
            Array.Copy(data, dataForTwoWayInsertion, data.Length);

            Console.WriteLine("\nЗапуск пирамидальной сортировки...");
            string pyramidalSortOutput = "pyramidal_sort_output.txt";
            long pyramidalSortTime = PyramidalSortProcedure(dataForPyramidalSort, pyramidalSortOutput);

            Console.WriteLine("\nЗапуск сортировки двухпутевыми вставками...");
            string twoWayInsertionOutput = "two_way_insertion_output.txt";
            long twoWayInsertionTime = TwoWayInsertionSortProcedure(dataForTwoWayInsertion, twoWayInsertionOutput);

            if (twoWayInsertionTime != -1)
            {
                AnalyzeStability(data, dataForPyramidalSort, dataForTwoWayInsertion);
            }

            CompareSortingTimes(pyramidalSortTime, twoWayInsertionTime);
            AnalyzeBestWorstCases(data);
        }
        catch (Exception e)
        {
            Console.WriteLine("Exception: " + e.Message);
        }
        finally
        {
            Console.WriteLine("\nПрограмма завершена.");
        }
    }

    public static DataRecord[] ReadData(string filename, int n)
    {
        List<DataRecord> records = new List<DataRecord>(n);
        int lineNumber = 1;

        try
        {
            using (var sr = new StreamReader(filename))
            {
                string line;
                while ((line = sr.ReadLine()) != null && records.Count < n)
                {
                    if (string.IsNullOrWhiteSpace(line))
                    {
                        lineNumber++;
                        continue;
                    }

                    string[] parts = line.Split('\t');
                    if (parts.Length >= 2)
                    {
                        string[] dateParts = parts[0].Split('-');
                        if (dateParts.Length >= 3 &&
                            int.TryParse(dateParts[0], out int year) &&
                            int.TryParse(dateParts[1], out int month) &&
                            int.TryParse(dateParts[2], out int day))
                        {
                            Date date = new Date(day, month, year);

                            string[] nameParts = parts[1].Split(' ');
                            if (nameParts.Length >= 3)
                            {
                                FullName name = new FullName(nameParts[0], nameParts[1], nameParts[2]);
                                records.Add(new DataRecord(date, name, lineNumber));
                            }
                        }
                    }

                    lineNumber++;
                    if (records.Count % 100000 == 0)
                    {
                        Console.WriteLine($"Прочитано записей: {records.Count}");
                    }
                }
            }
        }
        catch (Exception e)
        {
            Console.WriteLine("Exception: " + e.Message);
            return new DataRecord[0];
        }

        Console.WriteLine($"Всего обработано записей: {records.Count}");
        return records.ToArray();
    }

    public static long PyramidalSortProcedure(DataRecord[] data, string outputFile)
    {
        Stopwatch stopwatch = Stopwatch.StartNew();
        PyramidalSort(data, data.Length);
        stopwatch.Stop();
        long elapsedTime = stopwatch.ElapsedMilliseconds;

        WriteOutput(data, outputFile, elapsedTime);
        return elapsedTime;
    }

    // Исправленная пирамидальная сортировка
    public static void PyramidalSort(DataRecord[] data, int n)
    {
        // Построение max-heap
        for (int i = n / 2 - 1; i >= 0; i--)
            Heapify(data, n, i);

        // Последовательное извлечение элементов
        for (int i = n - 1; i > 0; i--)
        {
            Swap(data, 0, i);
            Heapify(data, i, 0);
        }
    }

    // Надежная рекурсивная версия Heapify
    private static void Heapify(DataRecord[] data, int n, int i)
    {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && data[left].CompareTo(data[largest]) > 0)
            largest = left;

        if (right < n && data[right].CompareTo(data[largest]) > 0)
            largest = right;

        if (largest != i)
        {
            Swap(data, i, largest);
            Heapify(data, n, largest);
        }
    }

    public static long TwoWayInsertionSortProcedure(DataRecord[] data, string outputFile)
    {
        if (data.Length > 50000)
        {
            Console.WriteLine($"Внимание: сортировка {data.Length} записей двухпутевыми вставками может занять значительное время");
        }

        Stopwatch stopwatch = Stopwatch.StartNew();
        try
        {
            OptimizedTwoWayInsertionSort(data, data.Length);
            stopwatch.Stop();
            long elapsedTime = stopwatch.ElapsedMilliseconds;
            WriteOutput(data, outputFile, elapsedTime);
            return elapsedTime;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            Console.WriteLine($"Ошибка при сортировке двухпутевыми вставками: {ex.Message}");
            return -1;
        }
    }

    public static void OptimizedTwoWayInsertionSort(DataRecord[] data, int n)
    {
        if (n <= 1) return;

        List<DataRecord> tempList = new List<DataRecord>(n * 2);
        for (int i = 0; i < n * 2; i++) tempList.Add(null);

        int left = n;
        int right = n;
        tempList[left] = data[0];

        for (int i = 1; i < n; i++)
        {
            DataRecord current = data[i];

            if (current.CompareTo(tempList[left]) < 0)
            {
                left--;
                tempList[left] = current;
            }
            else if (current.CompareTo(tempList[right]) > 0)
            {
                right++;
                tempList[right] = current;
            }
            else
            {
                int insertPos = BinarySearchPosition(tempList, left, right, current);
                for (int j = right; j >= insertPos; j--)
                {
                    tempList[j + 1] = tempList[j];
                }
                tempList[insertPos] = current;
                right++;
            }

            if (n > 10000 && i % 50000 == 0)
            {
                Console.WriteLine($"Обработано двухпутевыми вставками: {i}/{n}");
            }
        }

        for (int i = 0; i < n; i++)
        {
            data[i] = tempList[left + i];
        }
    }

    private static int BinarySearchPosition(List<DataRecord> list, int left, int right, DataRecord target)
    {
        int low = left;
        int high = right;

        while (low <= high)
        {
            int mid = low + (high - low) / 2;
            int comparison = target.CompareTo(list[mid]);

            if (comparison == 0) return mid;
            else if (comparison < 0) high = mid - 1;
            else low = mid + 1;
        }

        return low;
    }

    private static void Swap(DataRecord[] data, int i, int j)
    {
        DataRecord temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }

    private static void WriteOutput(DataRecord[] data, string filename, long sortingTime)
    {
        try
        {
            string outputDirectory = @"C:\Otvet";
            Directory.CreateDirectory(outputDirectory);
            string fullPath = Path.Combine(outputDirectory, filename);
            
            using (var writer = new StreamWriter(fullPath))
            {
                foreach (var record in data)
                {
                    writer.WriteLine(record);
                }
                writer.WriteLine($"Время сортировки: {sortingTime} мс");
            }
            Console.WriteLine($"Результаты сохранены в: {fullPath}");
        }
        catch (Exception e)
        {
            Console.WriteLine($"Ошибка записи: {e.Message}");
        }
    }

    public static void AnalyzeStability(DataRecord[] original, DataRecord[] pyramidalSorted, DataRecord[] twoWaySorted)
    {
        Console.WriteLine("\n=== АНАЛИЗ УСТОЙЧИВОСТИ ===");
        bool pyramidalStable = IsSortStable(original, pyramidalSorted);
        bool twoWayStable = IsSortStable(original, twoWaySorted);
        
        Console.WriteLine($"Пирамидальная: {(pyramidalStable ? "УСТОЙЧИВА" : "НЕУСТОЙЧИВА")}");
        Console.WriteLine($"Двухпутевые: {(twoWayStable ? "УСТОЙЧИВА" : "НЕУСТОЙЧИВА")}");
    }

    private static bool IsSortStable(DataRecord[] original, DataRecord[] sorted)
    {
        var groups = original
            .Select((r, i) => new { Record = r, Index = i })
            .GroupBy(x => $"{x.Record.Date}|{x.Record.Name}");

        foreach (var group in groups.Where(g => g.Count() > 1))
        {
            var originalOrder = group.Select(x => x.Index).ToList();
            var sortedOrder = new List<int>();

            foreach (var record in group)
            {
                int sortedIndex = Array.FindIndex(sorted, r =>
                    r.Date.Equals(record.Record.Date) &&
                    r.Name.Equals(record.Record.Name) &&
                    r.OriginalLineNumber == record.Record.OriginalLineNumber);

                if (sortedIndex >= 0) sortedOrder.Add(sortedIndex);
            }

            if (originalOrder.SequenceEqual(sortedOrder)) continue;
            return false;
        }

        return true;
    }

    public static void CompareSortingTimes(long pyramidalSortTime, long twoWayInsertionTime)
    {
        Console.WriteLine("\n=== СРАВНЕНИЕ ВРЕМЕНИ ===");
        Console.WriteLine($"Пирамидальная: {pyramidalSortTime} мс");
        
        if (twoWayInsertionTime != -1)
        {
            Console.WriteLine($"Двухпутевые: {twoWayInsertionTime} мс");
            if (pyramidalSortTime < twoWayInsertionTime)
                Console.WriteLine($"Пирамидальная быстрее на {twoWayInsertionTime - pyramidalSortTime} мс");
            else
                Console.WriteLine($"Двухпутевые быстрее на {pyramidalSortTime - twoWayInsertionTime} мс");
        }
        else
        {
            Console.WriteLine("Двухпутевые: НЕ ЗАВЕРШЕНА");
        }
    }

    public static void AnalyzeBestWorstCases(DataRecord[] sampleData)
    {
        Console.WriteLine("\n=== АНАЛИЗ СЛУЧАЕВ ===");
        int testSize = Math.Min(sampleData.Length, 1000);
        DataRecord[] testData = new DataRecord[testSize];
        Array.Copy(sampleData, testData, testSize);

        TestPerformanceOnCase(testData.OrderBy(x => x).ToArray(), "Наилучший случай");
        TestPerformanceOnCase(testData.OrderByDescending(x => x).ToArray(), "Наихудший случай");
        TestPerformanceOnCase(testData, "Случайные данные");
    }

    private static void TestPerformanceOnCase(DataRecord[] data, string caseName)
    {
        DataRecord[] pyramidalData = new DataRecord[data.Length];
        Array.Copy(data, pyramidalData, data.Length);
        
        var stopwatch = Stopwatch.StartNew();
        PyramidalSort(pyramidalData, pyramidalData.Length);
        stopwatch.Stop();
        long pyramidalTime = stopwatch.ElapsedMilliseconds;

        DataRecord[] twoWayData = new DataRecord[data.Length];
        Array.Copy(data, twoWayData, data.Length);
        
        stopwatch.Restart();
        OptimizedTwoWayInsertionSort(twoWayData, twoWayData.Length);
        stopwatch.Stop();
        long twoWayTime = stopwatch.ElapsedMilliseconds;

        Console.WriteLine($"{caseName}: Пирамидальная={pyramidalTime}мс, Двухпутевые={twoWayTime}мс");
    }
}
